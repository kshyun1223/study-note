### 구조분해할당(Destructuring assignment)

* 배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게 하는 표현식

```javascript
// 일반적인 객체 할당 방식
let second = ho.eunsoo.address.region.detail.second

// 구조분해할당 방식
const {eunsoo:{address:{region:{detail:{second:variable}}}}} = ho;
```

### this 키워드

```javascript
    element.addEventListener('click', function() {
      this.style.backgroundColor = "pink";
    });
```

* 매번 반복설명하는 것을 편리하게 지정할 수 있게 해줌
* 콘솔에 출력해서 무슨 값이 나오는지만 확인하면 간단하게 해결된다

### 화살표함수(arrow function)

```javascript
const scopeDebugging = {
  whatThis: function(){
    console.log(this); // whatThis: [Function: whatThis]
  },
  arrowThis : () => {
    console.log(this); // arrowThis: [Function: arrowThis] 
  }
}
console.log(scopeDebugging.whatThis());
console.log(scopeDebugging.arrowThis());
```

* 화살표함수는 콜백함수 내부에서 this가 전역객체를 가리키는 문제를 해결하는 대안으로 유용하다
* 화살표함수는 함수선언문으로 정의할 수 없고 함수표현식으로 정의해야 한다
* 매개변수가 한개인 경우 소괄호를 생략할 수 있다
* 표현식 하나로만 구성된 경우에는 중괄호를 생략할 수 있다
  * 표현식: 값으로 평가될 수 있는 구문

### 템플릿 리터럴 - 표현식 삽입(expression interpolation)

* 문자열 안에 표현식을 삽입하여 연산자보다 효율적으로 문자열을 조합할 수 있다
* 방법: `${}`으로 표현식을 감싼다

### 모듈

* html 파일에 script 태그로 외부 스크립트 파일 호출
* `<script src="./index.js" type=”module” defer></script>`
* 외부 스크립트 파일이 하나가 아니라 여러개인 경우 반드시 모듈이라고 선언해야 사용이 가능하다
* npm init으로 생성된 package.json 파일에도 “type”:”module”이라고 추가해야 한다
* 스크립트에 defer 어트리뷰트를 적용하면 HTML 파싱(DOM 생성)이 완료된 이후에 DOMContentLoaded 이벤트의 발생과 함께 스크립트가 실행된다

### 생성자함수(constructor function)에 의한 객체 생성

* 객체 리터럴은 한번에 하나의 객체만 생성한다. 따라서 동일한 프로퍼티를 갖는 객체를 여러개 생성해야 하려면 각각 새로 작성해야 하기 때문에 비효율적이다.
* 생성자함수에 의한 객체 생성은 마치 객체를 생성하기 위한 템플릿처럼 생성자함수를 사용하여 동일한 프로퍼티를 갖는 객체들을 간편하게 생성할 수 있다

## SPA

### 개요

페이지 전체를 렌더링 하는 것은 최초 한 번 뿐이다

그리고 요청이 들어올 때마다 필요한 데이터만을 부분적으로 리렌더링 한다

### 장점

필요한 모든 정적 자원을 한번에 렌더링 하기 때문에 최초 렌더링은 느리지만, 이후의 컨텐츠 변경은 매우 빠르다

## SEO

### 원론적인 정의

검색엔진에게 웹사이트가 우선순위로 인식 될 수 있게 최적화하는 과정

동일한 내용을 담고 있는 웹사이트의 경우 웹 표준을 잘 준수하는 쪽이 우선순위가 높다

기본적으로 헤더의 정보들이 바디의 내용보다 우선순위가 높기 때문에 브라우저에 출력되지 않는다고 해서 헤더를 등한시하면 안된다

그리고 바디의 내용 중에서는 대표적으로 h1 계열의 태그가 p 태그보다 우선순위가 높다

또한 시맨틱 태그를 준수하는 쪽이 그러지 않는 쪽보다 우선순위가 높다

### SPA에서의 관점

SPA는 최초 렌더링 이후에는 부분적으로만 컨텐츠를 변경한다

기본적으로 라우팅이 이루어지지 않기 때문에 세부적인 컨텐츠들이 검색엔진에 아예 인식 자체가 되지 않는다

따라서 SPA에서는 history 객체를 조작해서 라우팅부터 만드는 것이 우선이다

## AJAX

### 개요

Asynchronous JavaScript And XML의 약자이다

본래 어원은 XMLHttpRequest를 의미하는 것이었지만, 이후 Axios나 Fetch 등 후속 기술도 통칭하는 용어로 자리잡았다

비동기(Asynchronous)라는 이름이 붙은 이유는 페이지를 새로고침 하지 않고도 서버에 요청을 보내고 응답을 받아서 작업을 수행할 수 있기 때문이다

SPA를 구현하는 핵심 기술이다

## Prototype

### 프로토타입

자바스크립트의 모든 객체들은 메소드와 속성을 상속 받기 위한 템플릿인 프로토타입 객체를 가진다

각각의 프로토타입 객체들은 객체 노드에서 메소드와 속성을 상속받고 상속해줄 수 있다

프로토타입 객체들 간의 상속 관계를 프로토타입 체인(prototype chain)이라고 부른다

### 프로토타입 기반 객체지향 언어

클래스 기반 프로그래밍 언어들은 객체를 생성하기 전에 먼저 클래스를 정의하고 이를 통해 객체 인스턴스를 생성한다

반면 자바스크립트는 ES6에서 클래스가 도입되긴 했지만 그 이전에도 프로토타입을 통해 객체를 생성할 수 있었다

그리고 클래스 또한 개발자의 편의를 위한 시각적인 기능일 뿐이며 내부적으로는 프로토타입으로 동작한다

### 프로토타입의 장점

클래스에 비해 상속 매커니즘이 단순하므로 성능면에서 유리하다

## Hoisting

### 실행 컨텍스트 형성

자바스크립트 엔진이 코드가 실행되기 전에 실행 가능한 코드를 형상화하고 구분하는 과정

### 호이스팅

실행 컨텍스트를 형성하는 과정에서 모든 선언(변수, 함수, 클래스)들이 메모리 공간에 미리 할당되는 것

선언문보다 참조나 호출이 먼저 나와도 제대로 동작할 수 있는 것은 호이스팅 때문이다

마치 선언 구문이 파일의 최상단으로 끌어올려진(hoisting) 것처럼 보이지만 실제로 그런 것은 아니다
